# MySQL数据库的设计

写这篇文档，也算是“知耻而后勇”吧哈哈，之前在学习`MySQL`的时候也就学了那么几条增删改查`sql`语句，然后面试传智工作室的时候被问到数据库的知识只好说不会，然后回来就下定决心要好好整一整数据库了



### 一、数据库字段类型

> 说实话，用了这么久`MySQL`，字段类型大都是用的时候复制粘贴的，真的有点惭愧，下面就总结一下一些常用的吧



##### 1. 数值类型

`TINYINT`：大小仅为1字节，适合用于存储某些**布尔类型**和**性别**这样的数据

`INT`/`BIGINT`：整数值，具体根据业务需求来用吧

`DECIMAL`：浮点数类型，一般存储小数用的都是这个，很少用`FLOAT`和`DOUBLE`



##### 2. 字符串类型

`CHAR`：这个不是字符，而是**很短的**字符串，看业务需求要不要用到

`VARCHAR`：这其实就是字符串，一般是用的最多的了，常见的有账号密码啥的



##### 3. 日期类型

使用`spring boot`向`MySQL`插入`Java Date`类型的数据时，会自动转换为`DATETIME`的类型的

`DATE`：格式是`YYYY-MM-DD`

`TIMESTAMP`：时间戳，格式是`YYYY-MM-DD hh:mm:ss`

`DATETIME`：格式和`TIMESTAMP`一样，但是范围更广





### 二、数据库特性

> 真的不得不说，自己在`MySQL`数据库学习方面真的是半吊子，一些常用的数据库特性都没什么深刻的印象，于是在这里总结一下
>
> 但是这个东西有点多，详情请参考这篇文档吧：以这篇文档为参考：[MySQL | 菜鸟教程 (runoob.com)](https://www.runoob.com/mysql/mysql)



##### 1. 主键

主键是用于搜索和查询的时候提高速度用的，并且具有唯一性

主键不能为`NULL`，并且每张表只能有一个主键

主键分为**联合主键**和**单字段主键**，看业务逻辑来就好

设置主键约束：

```sql
CREATE TABLE table_name(
    `id` VARCHAR(20) NOT NULL COMMENT`唯一标识符`,
    `name` VARCHAR(25) NOT NULL COMMENT`名字`,
    PRIMARY KEY(`id`, `name`) 
); 
```



##### 2. 索引

索引也是用于加快搜索速度的，那么它和主键有什么区别呢？

索引包括了主键，还有唯一索引、复合索引等等

唯一索引的值可以为`NULL`，但是只能有一个值为`NULL`，因为不能重复

设置索引：`index_name`必须是唯一的

```sql
// 复合索引
CREATE TABLE table_name (
	`id` VARCHAR(20) NOT NULL COMMENT`唯一标识符`,
    `name` VARCHAR(25) NOT NULL COMMENT`名字`,
    INDEX index_name (`id`, `name`)
);
```



##### 3. 日期函数

使用`NOW()`可以获取当前的`DATETIME`，然后可以使用如下代码向数据库表中插入数据

```sql
INSERT INTO table (datetime_col) VALUES (NOW());
```





### 三、数据库表的设计

> 这应该是这篇文档最主要的部分了，之前我一直都不知道怎样去设计一个相对复杂的数据库，现在就来入门一下



##### 1. 数据库设计范式



* `第一范式`：

数据库表中的每个字段必须“原子化”，意思就是字段不可以再细分才是合理的，比如说下面的表格

在这个表格中，`phone_number`字段既有个人号码，也有座机，这实际上是数据冗余，应该分开来或者只存储一个，用逗号来分割并不好

| name   | phone_number |
| :--- | ------------ |
| lordmoon | 12345678909，356678 |



* `第二范式`：

一张表的主键字段必须能够确定其他非主键字段的值（非主键字段必须完全依赖于主键字段，而不能只依赖于主键字段的一部分）。简单来说，就是一张表只能做一件事

下面这张表格，有一个联合主键，但是部门楼层它只依赖于部门类别，但是不依赖于姓名

也就是说该非主键字段仅依赖于联合主键的一部分，而没有依赖全部

| 部门楼层 | 部门类别（主键） | 姓名（主键） |
| -------- | ---------------- | ------------ |
| 三楼     | 奇客社           | lordmoon     |
| 一楼     | 创客空间         | fzx          |



* `第三范式`：

数据库表中的每个非主键字段必须依赖于主键字段

下面的表格中部门楼层其实不依赖于姓名，而依赖于部门类别，所以我们应该把部门相关信息单独分出来一张表

| 部门楼层 | 部门类别 | 姓名（主键） |
| -------- | -------- | ------------ |
| 三楼     | 奇客社   | lordmoon     |
| 一楼     | 创客空间 | fzx          |





##### 2. 数据库设计流程

* `找出实体`

这里实际上就是确定有哪些表，有多少个实体，一般就对应对少张表



* `找出各个实体对应的属性`

实体中的每个属性，就相当于数据库表中的每个字段



* `找出各实体间对应的关系`

找出每个实体之间的关系，可以更好地设计主键和索引，建立数据库表的联系



* `作E-R图`

作出E-R图，可以更明确这个数据库的设计结构





##### 3. 数据库表设计实用技巧



* `当数据库实体间的关系为多对多时`

当实体为多对多关系的时候，我们一般会创建多一张中间表，用于表示对应关系

例如下面两张表，商品可以对应多张订单，订单可以对应多个商品

然后我们就用了一张中间表来实现关系的对应

商品表：

| 商品id | 商品价格 |
| ------ | -------- |
| 123    | 54.5     |

中间表：

| 订单id | 商品id |
| ------ | ------ |
| 456    | 123    |

订单表：

| 订单id | 订单创建日期 |
| ------ | ------------ |
| 456    | 1999-10-10   |



* `当数据库实体间关系为一对多时`

这种情况和上面的很像，主流的方法也是用中间表建立关系，这里我们详细展开说说

详情可参考这篇文档：[如何在 MySQL 中存储数组 | D栈 - Delft Stack](https://www.delftstack.com/zh/howto/mysql/store-array-in-mysql/)



我们可以使用`INNER JOIN`来进行连表查询

例如下面的数据库表

* `customer`表

| id   | name |
| ---- | ---- |
| 1    | ldm  |
| 2    | fzx  |

* `order`表

| order_id | order |
| -------- | ----- |
| 1        | 床单  |
| 2        | 枕头  |
| 3        | 面包  |

* `customer_oredr`表（中间表）

| customer_id | order_id |
| ----------- | -------- |
| 1           | 1        |
| 1           | 3        |
| 1           | 2        |
| 2           | 3        |

我们使用`INNER JOIN`进行查询，这样就可以建立起联系

```sql
SELECT c.name, c.order
FROM customer c
INNER JOIN customer_order co 
ON c.id = co.costomer_id
INNER JOIN order o  
ON o.order_id = co.order_id
WHERE name = 'ldm'
```





除此之外，我们还可以使用`MySQL`中的`JSON`数据类型来操作

**TODO**...





### 四、数据库表设计实操

> 其实之前一直有想写一个聊天桌面应用的想法，或许我会把这个作为`Java`的课设吧（虽然现在考虑这个有点早了哈哈），然后刚好就拿这个聊天软件的数据库表设计来练练手吧



先讲一下需求吧：

* 用户必须注册账户后才可登录
* 用户登录后可以通过账号id来搜索其他用户，并可以添加好友
* 添加好友后，可以拉起群聊，拉起人就是群主
* 其他用户可以通过群号来加入群聊，即使与群里的其他人没有好友关系
* 在群里也可以添加好友
* 群主可以解散群聊，群友可以退出群聊



##### 1. 找出实体

* 单个用户
* 群聊
* 好友



##### 2. 各个实体的属性

* 用户属性：
  * 账号、密码、性别、好友个数、群聊个数
* 群聊属性：
  * 群聊号码、群成员、群聊名称、群聊创建时间、群主
* 好友属性：
  * 添加好友日期、主动添加人的账号、被添加人的账号



##### 3. 实体之间的关系

用户与群聊之间是`多对多`的关系，一个用户可以对应多个群聊，一个群聊里面也可以有多个用户

用户与好友是`一对多`的关系，一个用户可以有多个好友

群聊是属于用户的（反过来好像也没什么问题哈哈）

好友是属于用户的



##### 4. 作出E-R图

![](http://ldmblog.ifoodin.com/%E6%A1%8C%E9%9D%A2%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%BA%93E-R.png)



##### 5. 设计数据库表

* 用户表

| 字段名         | 字段说明                               |
| -------------- | -------------------------------------- |
| `id`           | 主键，自增                             |
| `user_account` | 用户账号，唯一，和`id`一起作为联合主键 |
| `user_pwd`     | 用户密码                               |
| `user_gender`  | 用户性别                               |
| `group_count`  | 用户加入的群聊数量                     |
| `friend_count` | 用户的好友数量                         |
| `user_token`   | 用户登录凭证                           |

* 群聊表

| 字段名              | 字段说明                           |
| ------------------- | ---------------------------------- |
| `id`                | 主键，自增                         |
| `group_num`         | 群号，唯一，和`id`一起作为联合主键 |
| `group_name`        | 群聊名称                           |
| `group_create_time` | 群聊创建时间                       |
| `group_owner`       | 群主                               |

* 群成员表（用于说明用户和群聊之间的关系）

| 字段名         | 字段说明       |
| -------------- | -------------- |
| `id`           | 主键，自增     |
| `group_num`    | 群号，索引     |
| `user_account` | 用户账号，索引 |

* 好友表

| 字段名           | 字段说明                                       |
| ---------------- | ---------------------------------------------- |
| `id`             | 主键，自增                                     |
| `user_account`   | 添加人账号                                     |
| `friend_account` | 被添加的账号                                   |
| `friend_status`  | 添加状态，-1表示未处理，1表示已接受，0表示拒绝 |

